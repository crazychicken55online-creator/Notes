# [Two Sum - LeetCode](https://leetcode.com/problems/two-sum/description/)
## Problem
Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.
You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.
You can return the answer in any order.
## Approach
- NO BRUTE FORCE
- We can make a hash map that will store every index of the `nums` array as: `nums[i]:i`.
	- Need to hard code the first value to account for duplicates, if we don't hard code the first value the `hash_map[nums[i]]=i` has to be at the very top of the for loop, we want it at the very bottom so edge cases like `nums=[3,3]; target = 6` will evaluate to True.
		- Would otherwise evaluate to None (null) as the `hash_map` would have its value for 3 updated to the new index (1) before `required_val` is checked, and since `required_val` index would be equal to i, it would not return a value and the for loop will just end.
- We can then check if `target-nums[i]` already exists within the hash map, it it does and `i!=hash[target-nums[i]]` then we can return `hash(target-nums[i])`(basically checking if the index of the value that makes `target-nums[i]` have a valid value isn't just at index `i`).
## Solution
```python title=two_sum_sol.py
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        hash_table = {}
        hash_table[nums[0]]=0
        for i in range(1,len(nums)):
            required_val = target-nums[i]
            if required_val in hash_table:
                if hash_table[required_val]!=i:
                    return (hash_table[required_val],i)
            hash_table[nums[i]]=i
```
## Complexities
- Time: `O(n)`
- Space: `O(n)`