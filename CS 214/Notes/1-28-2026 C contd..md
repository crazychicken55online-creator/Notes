# Recap
- Enumerated types:
`enum color {red, green, blue}`
- Arrays: Collection of objects of the same type.
	- Index starts 0, represents how far from the first you need to be in order to access the element.
- Structs: Collection of objects of different types accessed by name.
```c
struct student_record {
	char *name;
	int ruid;
	enum color favorite_color;
}
```
- Union: Objects that may have one of various types.
```c
union student_or_integer {
	struct student stu;
	int i;
	double d;
	enum color sky;
}
```
In C no types is stored during runtime, the compiler only cares about the runtime when it creates the assembly code, after which the assembly is converted to byte code, all of which is inherently type safe due to the compiler being mindful of types during compilation.
# Size of Data
`sizeof()`: Gives the number of bytes (chars, since each `char` is one byte) used to store some data.
```c
sizeof(int) // 4
sizeof(char) // 1, by definition.
sizeof(char) == 1 // true, by definition.
```
C does calculates the size of data as number of `char`.
Data sizes can change, `int` used to be 2 bytes, it is now 4.
```c
sizeof(struct student) // at least the size of all the data within the struct
struct student p
sizeof(p) // gives you the size of p (which COULD be the size of struct student).
int a[20];
sizeof(a) // will be 20*sizeof(int)
```
- Array sizes are not kept during runtime, you need to either change the implementation or keep track of the size of the array.
## Chars
'A' == 65 (assuming ASCII).
You can `#include<ctype.h>`.
- Has functions such as `isalpha(c)`, `isdigit(c)`, `isalphanum(c)`, `isspace()`, `toupper()`, `tolower()`.
```c
// make entire word uppercase
#include<ctype.h>
// O(n^2)
void all_caps(char *str){
	for(int i = 0; i < strlen(str); i++){
		str[i] = toupper(str[i]);
	}
}
// O(n) note: ~2n
void all_caps(char *str){
	int len = strlen(str)
	for(int i = 0; i < len; i++){
		str[i] = toupper(str[i]);
	}
}
// O(n) note ~n
void all_caps(char *str){
	for(int i = 0; str[i]!='\0'; i++){
		str[i] = toupper(str[i]);
	}
}
```
- You cannot assign to an array name, you need to copy it within the memory of the array.
```c
char a[100];
a = "hello" // WILL NOT WORK
strcpy(a, "hello"); // same order as the assignment operator
// Note that a is still an array of 100 chars.
strlen(a) == 5 // string hello is only of length 5
// HOWEVER
sizeof(a) == 100 // still has the 100 chars of memory
```
- You can find the lexicographic ordering of a and b.
	- Shorter one comes first, if they are of the same length, the one with the earlier letters comes first.
```c
strcmp(a, b)
```
- Will return 0 if the strings are equal.
- Will return negative if a comes before b.
- Will return positive if a comes after b.
```c
strcmp("hello", "hello!") == -1
```
- If you know the length of the source and the destination strings you can use `memcpy` instead of `strcpy` as it is faster.
```c
memcpy(dist, src, count);
// requires explicitly saying how many bytes to copy.
// does not need to check for the terminator.
// this is the fastest way to copy data.
```
- `memcpy` uses OS-level tricks in order to optimize the copy, it is never worse and almost always better than copying memory yourself.
## Integer Tricks
Integer literals starting with 1-9 are decimal.
- E.g., 10 means ten.
Integer literals starting with 0 are octal.
- E.g., 010 means eight.
Integer literals starting with 0x or 0X are hexadecimal.
- E.g., 0x10 means sixteen.
- E.g., 0xCAFE means 51966.
- 0x7F is the largest 7-bit value.
Putting U at the end of a literal makes it unsigned.
Putting L at the end of literal make sit long.
## Output
`printf() - print formatted`
- Takes one or more arguments.
- First argument is a format string, which can contain 0 or more format specifiers `%<code>`.
	- Specifiers usually refer to an argument, indicating to the function what type of argument we are passing and what type for formatting we need for that argument.
```c
printf("Here is an int: %d\n", 235); // prints decimal number 235
```
`%d` : decimal integer.
`%o` : octal integer.
`%x %X`: hexadecimal integer.
`%f`: floating point.
`%e`: floating point in scientific notation. (`1.0e10`)
`%g`: either `%f`  or `%e`, whichever is better, helpful for large numbers.
`%c`: character
`%s`: string
Before the format code we can add a size field.
- `%ld`: long integer.
- `%hd`: short integer, rarely used.
Immediately after the `%` we can have a width.
- `%10d`: Print an `int` in a 10-`char` column, right justified.
- `-10d`: Print an `int` in a 10-`char` column, left justified.
- `%10.3f`: Print a `float` in a 10-`char` column, with 3 digits after the decimal point, right justified.
```c
int main(int argc, char **argv){
	for(int i = 0; i < argc; i++){
		printf("Argument %d is %s\n", i, argv[i]);
	}
	return EXIT_SUCCESS;
}
```
You can use `man 3 <function name>` to get documentation of a C function, on Linux.
# Pointers
A pointer is an address in memory.
- It is a number that indicates a location in memory.
All data is accessed by address, the compiler keeps tracks of where variables, literals, functions are stored.
We can explicitly get the location of data.
- For variables and variable-like expression, we can use `&`.
```c
int x = 5;
&x // evaluates to a pointer to x (which is address or location in memory of the first byte of integer x).
```
Pointers are typed. (They have types).
- E.g., A pointer to an `int` is typed `int *`.
We can create pointer variables ourselves.
```c
int *p; // p is a pointer variable; it contains the address of an int
p = &x; // p now stores the address of x.
```
The unary `*` "dereferences" a pointer, it lets us talk about the object it points to.
`p`: The address of `x`.
`*p:` The value of `x` (The  thing being pointed to).
`*p = 10`, this changes the value of the variable `x` to 10.
```c
int y = 7;
p = &y; // VALID, p now points to y, no longer cares about x.
p = y // INVALID, not allowed as y is an int and p is a int *.
```
Special pointer value: NULL.
- Points explicitly to nothing.
- If you deference NULL, your program will crash.
- It is also considered false.
```c
int a[100];
int *p;
p = a; // p now points to the array a, p points to the first value of a, a[0].
*p == a[0] == *a == p[0];
```
An `int` array of size 1 is the same as a regular `int`.
